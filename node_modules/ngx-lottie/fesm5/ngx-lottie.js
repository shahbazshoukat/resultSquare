import { InjectionToken, Injectable, NgZone, Inject, PLATFORM_ID, EventEmitter, Directive, Input, Output, ElementRef, Self, Component, ChangeDetectionStrategy, Renderer2, ViewChild, NgModule, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';
import { isPlatformServer, DOCUMENT, CommonModule } from '@angular/common';
import { from, throwError, of, Subject } from 'rxjs';
import { map, catchError, shareReplay, takeUntil } from 'rxjs/operators';
import { __read, __values, __extends } from 'tslib';
import { makeStateKey, TransferState } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * Generated from: src/utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} animation
 * @return {?}
 */
function transformAnimationFilenameToKey(animation) {
    return "animation-" + animation.split('.json')[0];
}
/**
 * @param {?} player
 * @param {?} href
 * @param {?} isSafari
 * @return {?}
 */
function setPlayerLocationHref(player, href, isSafari) {
    // This is a fix for the mask on Safari/iOS
    // https://github.com/airbnb/lottie-web/issues/1198
    if (isSafari) {
        ((/** @type {?} */ (((/** @type {?} */ (player)))))).setLocationHref(href);
    }
}
/**
 * @param {?} options
 * @param {?} container
 * @param {?} animationCache
 * @return {?}
 */
function mergeOptionsWithDefault(options, container, animationCache) {
    /** @type {?} */
    var merged = Object.assign({
        container: container,
        renderer: 'svg',
        loop: true,
        autoplay: true
    }, options);
    if (animationCache !== null) {
        return animationCache.transformOptions(merged);
    }
    return merged;
}
/**
 * @return {?}
 */
function isSafariFactory() {
    // This `try-catch` block will also handle server-side rendering
    // as `navigator` is not accessable there
    try {
        var vendor = navigator.vendor, userAgent = navigator.userAgent;
        return (vendor.indexOf('Apple') > -1 &&
            userAgent.indexOf('CriOS') === -1 &&
            userAgent.indexOf('FxiOS') === -1);
    }
    catch (_a) {
        return false;
    }
}
/**
 * @param {?} options
 * @return {?}
 */
function isAnimationConfigWithData(options) {
    /** @type {?} */
    var animationData = ((/** @type {?} */ (options))).animationData;
    return animationData !== null && typeof animationData === 'object';
}
/**
 * @param {?} animationCache
 * @param {?} options
 * @param {?} animationItem
 * @return {?}
 */
function awaitConfigAndCache(animationCache, options, animationItem) {
    if (animationCache === null) {
        return;
    }
    animationItem.addEventListener('config_ready', (/**
     * @return {?}
     */
    function () {
        animationCache.set(options, animationItem);
    }));
}
/**
 * @param {?} player
 * @return {?}
 */
function streamifyPlayerOrLoader(player) {
    /** @type {?} */
    var playerOrLoader = player();
    if (playerOrLoader instanceof Promise) {
        return from(playerOrLoader).pipe(map((/**
         * @param {?} module
         * @return {?}
         */
        function (module) { return module.default || module; })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            console.error("\n          Could not retrieve the \"lottie-web\" player, did you provide\n          the \"player\" property correctly?\n          export function playerFactory() {\n            return import('lottie-web');\n          }\n          LottieModule.forRoot({ player: playerFactory })\n        ");
            return throwError(error);
        })), shareReplay(1));
    }
    return of(playerOrLoader);
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/symbols.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function BMEnterFrameEvent() { }
if (false) {
    /** @type {?} */
    BMEnterFrameEvent.prototype.currentTime;
    /** @type {?} */
    BMEnterFrameEvent.prototype.duration;
    /** @type {?} */
    BMEnterFrameEvent.prototype.totalTime;
    /** @type {?} */
    BMEnterFrameEvent.prototype.type;
}
/**
 * @record
 */
function BMCompleteLoopEvent() { }
if (false) {
    /** @type {?} */
    BMCompleteLoopEvent.prototype.type;
    /** @type {?} */
    BMCompleteLoopEvent.prototype.loop;
    /** @type {?} */
    BMCompleteLoopEvent.prototype.playCount;
    /** @type {?} */
    BMCompleteLoopEvent.prototype.frameMult;
}
/**
 * @record
 */
function BMCompleteEvent() { }
if (false) {
    /** @type {?} */
    BMCompleteEvent.prototype.type;
    /** @type {?} */
    BMCompleteEvent.prototype.duration;
}
/**
 * @record
 */
function BMSegmentStartEvent() { }
if (false) {
    /** @type {?} */
    BMSegmentStartEvent.prototype.type;
    /** @type {?} */
    BMSegmentStartEvent.prototype.firstFrame;
    /** @type {?} */
    BMSegmentStartEvent.prototype.totalFrames;
}
/**
 * @record
 */
function BMDestroyEvent() { }
if (false) {
    /** @type {?} */
    BMDestroyEvent.prototype.target;
    /** @type {?} */
    BMDestroyEvent.prototype.type;
}
/**
 * @record
 */
function BMRenderFrameErrorEvent() { }
if (false) {
    /** @type {?} */
    BMRenderFrameErrorEvent.prototype.type;
    /** @type {?} */
    BMRenderFrameErrorEvent.prototype.nativeError;
    /** @type {?} */
    BMRenderFrameErrorEvent.prototype.currentTime;
}
/**
 * @record
 */
function BMConfigErrorEvent() { }
if (false) {
    /** @type {?} */
    BMConfigErrorEvent.prototype.type;
    /** @type {?} */
    BMConfigErrorEvent.prototype.nativeError;
}
/**
 * @record
 */
function LottieOptions() { }
if (false) {
    /** @type {?} */
    LottieOptions.prototype.player;
    /** @type {?|undefined} */
    LottieOptions.prototype.useCache;
}
/** @type {?} */
var IS_SAFARI = new InjectionToken('IsSafari');
/** @type {?} */
var LOTTIE_OPTIONS = new InjectionToken('LottieOptions');
/** @type {?} */
var ANIMATION_CACHE = new InjectionToken('AnimationCache');

/**
 * @fileoverview added by tsickle
 * Generated from: src/animation-loader.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// This has to be dynamic as `Document` interface is not
// accepted by the ngc compiler
// @dynamic
var AnimationLoader = /** @class */ (function () {
    function AnimationLoader(ngZone, platformId, document, isSafari, options, animationCache) {
        this.ngZone = ngZone;
        this.platformId = platformId;
        this.document = document;
        this.isSafari = isSafari;
        this.options = options;
        this.animationCache = animationCache;
        this.player$ = streamifyPlayerOrLoader(this.options.player);
    }
    /**
     * @param {?} options
     * @param {?} container
     * @param {?} eventsFacade
     * @param {?} animationCreated
     * @param {?} instance
     * @param {?} destroy$
     * @return {?}
     */
    AnimationLoader.prototype.resolveLoaderAndLoadAnimation = /**
     * @param {?} options
     * @param {?} container
     * @param {?} eventsFacade
     * @param {?} animationCreated
     * @param {?} instance
     * @param {?} destroy$
     * @return {?}
     */
    function (options, container, eventsFacade, animationCreated, instance, destroy$) {
        var _this = this;
        if (isPlatformServer(this.platformId)) {
            return;
        }
        this.player$.pipe(takeUntil(destroy$)).subscribe((/**
         * @param {?} player
         * @return {?}
         */
        function (player) {
            /** @type {?} */
            var mergedOptions = mergeOptionsWithDefault(options, container, _this.animationCache);
            _this.loadAnimation(player, mergedOptions, eventsFacade, animationCreated, instance);
        }));
    };
    /**
     * @private
     * @param {?} player
     * @param {?} options
     * @param {?} eventsFacade
     * @param {?} animationCreated
     * @param {?} instance
     * @return {?}
     */
    AnimationLoader.prototype.loadAnimation = /**
     * @private
     * @param {?} player
     * @param {?} options
     * @param {?} eventsFacade
     * @param {?} animationCreated
     * @param {?} instance
     * @return {?}
     */
    function (player, options, eventsFacade, animationCreated, instance) {
        setPlayerLocationHref(player, this.document.location.href, this.isSafari);
        /** @type {?} */
        var animationItem = this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        function () { return player.loadAnimation(options); }));
        awaitConfigAndCache(this.animationCache, options, animationItem);
        // Dispatch `animationCreated` event after animation is loaded successfully
        animationCreated.emit(animationItem);
        eventsFacade.addEventListeners(instance, animationItem);
    };
    AnimationLoader.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    AnimationLoader.ctorParameters = function () { return [
        { type: NgZone },
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [IS_SAFARI,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [LOTTIE_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [ANIMATION_CACHE,] }] }
    ]; };
    return AnimationLoader;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.player$;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.document;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.isSafari;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.options;
    /**
     * @type {?}
     * @private
     */
    AnimationLoader.prototype.animationCache;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/base.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BaseDirective = /** @class */ (function () {
    function BaseDirective(platformId, animationLoader) {
        this.platformId = platformId;
        this.animationLoader = animationLoader;
        this.options = null;
        this.containerClass = null;
        this.styles = null;
        this.width = null;
        this.height = null;
        /**
         * `animationCreated` is dispatched after calling `loadAnimation`
         */
        this.animationCreated = new EventEmitter();
        /**
         * `complete` is dispatched after completing the last frame
         */
        this.complete = new EventEmitter();
        /**
         * `loopComplete` is dispatched after completing frame loop
         */
        this.loopComplete = new EventEmitter();
        /**
         * `enterFrame` is dispatched after entering the new frame
         */
        this.enterFrame = new EventEmitter();
        /**
         * `segmentStart` is dispatched when the new segment is adjusted
         */
        this.segmentStart = new EventEmitter();
        /**
         * Original event name is `config_ready`. `config_ready` is dispatched
         * after the needed renderer is configured
         */
        this.configReady = new EventEmitter();
        /**
         * Original event name is `data_ready`. `data_ready` is dispatched
         * when all parts of the animation have been loaded
         */
        this.dataReady = new EventEmitter();
        /**
         * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched
         * when elements have been added to the DOM
         */
        this.domLoaded = new EventEmitter();
        /**
         * `destroy` will be dispatched in the `ngOnDestroy` hook of the service,
         * it's useful for releasing resources
         */
        this.destroy = new EventEmitter();
        /**
         * `error` will be dispatched if the lottie player could not render
         * some frame or parse config
         */
        this.error = new EventEmitter();
        this.destroy$ = new Subject();
    }
    /**
     * @return {?}
     */
    BaseDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy$.next();
        this.destroy$.complete();
    };
    /**
     * @protected
     * @return {?}
     */
    BaseDirective.prototype.setWidthAndHeight = /**
     * @protected
     * @return {?}
     */
    function () {
        this.width = this.width || '100%';
        this.height = this.height || '100%';
    };
    /**
     * @protected
     * @param {?} container
     * @param {?} eventsFacade
     * @param {?} instance
     * @return {?}
     */
    BaseDirective.prototype.loadAnimation = /**
     * @protected
     * @param {?} container
     * @param {?} eventsFacade
     * @param {?} instance
     * @return {?}
     */
    function (container, eventsFacade, instance) {
        if (isPlatformServer(this.platformId)) {
            return;
        }
        this.animationLoader.resolveLoaderAndLoadAnimation(this.options, container, eventsFacade, this.animationCreated, instance, this.destroy$);
    };
    BaseDirective.decorators = [
        { type: Directive, args: [{ selector: '[lottie]' },] }
    ];
    /** @nocollapse */
    BaseDirective.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: AnimationLoader }
    ]; };
    BaseDirective.propDecorators = {
        options: [{ type: Input }],
        containerClass: [{ type: Input }],
        styles: [{ type: Input }],
        width: [{ type: Input }],
        height: [{ type: Input }],
        animationCreated: [{ type: Output }],
        complete: [{ type: Output }],
        loopComplete: [{ type: Output }],
        enterFrame: [{ type: Output }],
        segmentStart: [{ type: Output }],
        configReady: [{ type: Output }],
        dataReady: [{ type: Output }],
        domLoaded: [{ type: Output }],
        destroy: [{ type: Output }],
        error: [{ type: Output }]
    };
    return BaseDirective;
}());
if (false) {
    /** @type {?} */
    BaseDirective.prototype.options;
    /** @type {?} */
    BaseDirective.prototype.containerClass;
    /** @type {?} */
    BaseDirective.prototype.styles;
    /** @type {?} */
    BaseDirective.prototype.width;
    /** @type {?} */
    BaseDirective.prototype.height;
    /**
     * `animationCreated` is dispatched after calling `loadAnimation`
     * @type {?}
     */
    BaseDirective.prototype.animationCreated;
    /**
     * `complete` is dispatched after completing the last frame
     * @type {?}
     */
    BaseDirective.prototype.complete;
    /**
     * `loopComplete` is dispatched after completing frame loop
     * @type {?}
     */
    BaseDirective.prototype.loopComplete;
    /**
     * `enterFrame` is dispatched after entering the new frame
     * @type {?}
     */
    BaseDirective.prototype.enterFrame;
    /**
     * `segmentStart` is dispatched when the new segment is adjusted
     * @type {?}
     */
    BaseDirective.prototype.segmentStart;
    /**
     * Original event name is `config_ready`. `config_ready` is dispatched
     * after the needed renderer is configured
     * @type {?}
     */
    BaseDirective.prototype.configReady;
    /**
     * Original event name is `data_ready`. `data_ready` is dispatched
     * when all parts of the animation have been loaded
     * @type {?}
     */
    BaseDirective.prototype.dataReady;
    /**
     * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched
     * when elements have been added to the DOM
     * @type {?}
     */
    BaseDirective.prototype.domLoaded;
    /**
     * `destroy` will be dispatched in the `ngOnDestroy` hook of the service,
     * it's useful for releasing resources
     * @type {?}
     */
    BaseDirective.prototype.destroy;
    /**
     * `error` will be dispatched if the lottie player could not render
     * some frame or parse config
     * @type {?}
     */
    BaseDirective.prototype.error;
    /**
     * @type {?}
     * @private
     */
    BaseDirective.prototype.destroy$;
    /**
     * @type {?}
     * @private
     */
    BaseDirective.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    BaseDirective.prototype.animationLoader;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/animation-cache.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AnimationCache = /** @class */ (function () {
    function AnimationCache() {
        this.cache = new Map();
    }
    /**
     * @param {?} options
     * @return {?}
     */
    AnimationCache.create = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        if (options.useCache) {
            return new AnimationCache();
        }
        return null;
    };
    /**
     * @param {?} options
     * @return {?}
     */
    AnimationCache.prototype.transformOptions = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        /** @type {?} */
        var path = ((/** @type {?} */ (options))).path;
        if (path && this.cache.has(path)) {
            delete ((/** @type {?} */ (options))).path;
            ((/** @type {?} */ (options))).animationData = this.cache.get(path);
        }
        return options;
    };
    /**
     * @param {?} options
     * @param {?} animationItem
     * @return {?}
     */
    AnimationCache.prototype.set = /**
     * @param {?} options
     * @param {?} animationItem
     * @return {?}
     */
    function (options, animationItem) {
        if (isAnimationConfigWithData(options)) {
            return;
        }
        /** @type {?} */
        var animationData = animationItem['animationData'];
        this.cache.set((/** @type {?} */ (options.path)), animationData);
    };
    return AnimationCache;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    AnimationCache.prototype.cache;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/events-facade.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns only those `EventEmitter` instances that has attached observers
 * @param {?} instance
 * @param {?} eventsMap
 * @return {?}
 */
function getObservedEventEmitters(instance, eventsMap) {
    return Object.keys(instance)
        .map((/**
     * @param {?} key
     * @return {?}
     */
    function (key) { return [key, instance[key]]; }))
        .filter((/**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var _b = __read(_a, 2), key = _b[0], property = _b[1];
        return property instanceof EventEmitter &&
            property.observers.length > 0 &&
            eventsMap.hasOwnProperty(key);
    }))
        .map((/**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var _b = __read(_a, 2), key = _b[0], eventEmitter = _b[1];
        return ({
            eventEmitter: eventEmitter,
            name: eventsMap[key]
        });
    }));
}
var LottieEventsFacade = /** @class */ (function () {
    function LottieEventsFacade(ngZone, platformId) {
        this.ngZone = ngZone;
        this.platformId = platformId;
        /**
         * @see https://github.com/airbnb/lottie-web#events
         */
        this.eventsMap = {
            complete: 'complete',
            loopComplete: 'loopComplete',
            enterFrame: 'enterFrame',
            segmentStart: 'segmentStart',
            configReady: 'config_ready',
            dataReady: 'data_ready',
            domLoaded: 'DOMLoaded',
            destroy: 'destroy',
            error: 'error'
        };
        this.animationItem = null;
    }
    /**
     * @return {?}
     */
    LottieEventsFacade.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.dispose();
    };
    /**
     * @param {?} instance
     * @param {?} animationItem
     * @return {?}
     */
    LottieEventsFacade.prototype.addEventListeners = /**
     * @param {?} instance
     * @param {?} animationItem
     * @return {?}
     */
    function (instance, animationItem) {
        var _this = this;
        this.animationItem = animationItem;
        // `AnimationItem` triggers different events every ms, we have to listen
        // them outside Angular's context, thus it won't affect performance
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        function () { return _this.addEventListenersToObservedEventEmitters(instance); }));
    };
    /**
     * @private
     * @return {?}
     */
    LottieEventsFacade.prototype.dispose = /**
     * @private
     * @return {?}
     */
    function () {
        // The `ng-lottie` component or the `lottie` directive can be destroyed
        // before the `animationItem` is set, thus it will fail with
        // `Cannot read property 'destroy' of null`.
        // Potentially it can happen if the directive gets destroyed before change
        // detection is run.
        if (isPlatformServer(this.platformId) || this.animationItem === null) {
            return;
        }
        // `destroy()` will remove all events listeners
        this.animationItem.destroy();
        this.animationItem = null;
    };
    /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    LottieEventsFacade.prototype.addEventListenersToObservedEventEmitters = /**
     * @private
     * @param {?} instance
     * @return {?}
     */
    function (instance) {
        var e_1, _a;
        /** @type {?} */
        var observedEmitters = getObservedEventEmitters(instance, this.eventsMap);
        var _loop_1 = function (name_1, eventEmitter) {
            (/** @type {?} */ (this_1.animationItem)).addEventListener(name_1, (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                eventEmitter.emit(event);
            }));
        };
        var this_1 = this;
        try {
            for (var observedEmitters_1 = __values(observedEmitters), observedEmitters_1_1 = observedEmitters_1.next(); !observedEmitters_1_1.done; observedEmitters_1_1 = observedEmitters_1.next()) {
                var _b = observedEmitters_1_1.value, name_1 = _b.name, eventEmitter = _b.eventEmitter;
                _loop_1(name_1, eventEmitter);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (observedEmitters_1_1 && !observedEmitters_1_1.done && (_a = observedEmitters_1.return)) _a.call(observedEmitters_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    LottieEventsFacade.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    LottieEventsFacade.ctorParameters = function () { return [
        { type: NgZone },
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    return LottieEventsFacade;
}());
if (false) {
    /**
     * @see https://github.com/airbnb/lottie-web#events
     * @type {?}
     * @private
     */
    LottieEventsFacade.prototype.eventsMap;
    /**
     * @type {?}
     * @private
     */
    LottieEventsFacade.prototype.animationItem;
    /**
     * @type {?}
     * @private
     */
    LottieEventsFacade.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    LottieEventsFacade.prototype.platformId;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/lottie.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LottieDirective = /** @class */ (function (_super) {
    __extends(LottieDirective, _super);
    function LottieDirective(platformId, host, eventsFacade, animationLoader) {
        var _this = _super.call(this, platformId, animationLoader) || this;
        _this.host = host;
        _this.eventsFacade = eventsFacade;
        return _this;
    }
    /**
     * @return {?}
     */
    LottieDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.loadAnimation.call(this, this.host.nativeElement, this.eventsFacade, this);
    };
    LottieDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[lottie]',
                    providers: [LottieEventsFacade]
                },] }
    ];
    /** @nocollapse */
    LottieDirective.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: ElementRef, decorators: [{ type: Self }] },
        { type: LottieEventsFacade, decorators: [{ type: Self }] },
        { type: AnimationLoader }
    ]; };
    return LottieDirective;
}(BaseDirective));
if (false) {
    /**
     * @type {?}
     * @private
     */
    LottieDirective.prototype.host;
    /**
     * @type {?}
     * @private
     */
    LottieDirective.prototype.eventsFacade;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/lottie.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LottieComponent = /** @class */ (function (_super) {
    __extends(LottieComponent, _super);
    function LottieComponent(renderer, platformId, eventsFacade, animationLoader) {
        var _this = _super.call(this, platformId, animationLoader) || this;
        _this.renderer = renderer;
        _this.eventsFacade = eventsFacade;
        _this.container = (/** @type {?} */ (null));
        return _this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    LottieComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var containerClass = changes.containerClass;
        if (containerClass === undefined || typeof containerClass.currentValue !== 'string') {
            return;
        }
        this.renderer.addClass(this.container.nativeElement, containerClass.currentValue);
    };
    /**
     * @return {?}
     */
    LottieComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.setWidthAndHeight.call(this);
        _super.prototype.loadAnimation.call(this, this.container.nativeElement, this.eventsFacade, this);
    };
    LottieComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ng-lottie',
                    template: "\n    <div #container [style.width]=\"width\" [style.height]=\"height\" [ngStyle]=\"styles\"></div>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [LottieEventsFacade]
                }] }
    ];
    /** @nocollapse */
    LottieComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: LottieEventsFacade, decorators: [{ type: Self }] },
        { type: AnimationLoader }
    ]; };
    LottieComponent.propDecorators = {
        container: [{ type: ViewChild, args: ['container', { static: true },] }]
    };
    return LottieComponent;
}(BaseDirective));
if (false) {
    /** @type {?} */
    LottieComponent.prototype.container;
    /**
     * @type {?}
     * @private
     */
    LottieComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    LottieComponent.prototype.eventsFacade;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/lottie.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LottieModule = /** @class */ (function () {
    function LottieModule() {
    }
    /**
     * @param {?} options
     * @return {?}
     */
    LottieModule.forRoot = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return {
            ngModule: LottieModule,
            providers: [
                AnimationLoader,
                {
                    provide: LOTTIE_OPTIONS,
                    useValue: options
                },
                {
                    provide: IS_SAFARI,
                    useFactory: isSafariFactory
                },
                {
                    provide: ANIMATION_CACHE,
                    useFactory: AnimationCache.create,
                    deps: [LOTTIE_OPTIONS]
                }
            ]
        };
    };
    LottieModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [BaseDirective, LottieDirective, LottieComponent],
                    exports: [BaseDirective, LottieDirective, LottieComponent]
                },] }
    ];
    return LottieModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: src/transfer-state.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LottieTransferState = /** @class */ (function () {
    function LottieTransferState(transferState) {
        this.transferState = transferState;
    }
    /**
     * @template T
     * @param {?} animation
     * @return {?}
     */
    LottieTransferState.prototype.get = /**
     * @template T
     * @param {?} animation
     * @return {?}
     */
    function (animation) {
        /** @type {?} */
        var animationKey = transformAnimationFilenameToKey(animation);
        /** @type {?} */
        var stateKey = makeStateKey(animationKey);
        return this.transferState.get(stateKey, null);
    };
    LottieTransferState.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    LottieTransferState.ctorParameters = function () { return [
        { type: TransferState }
    ]; };
    /** @nocollapse */ LottieTransferState.ɵprov = ɵɵdefineInjectable({ factory: function LottieTransferState_Factory() { return new LottieTransferState(ɵɵinject(TransferState)); }, token: LottieTransferState, providedIn: "root" });
    return LottieTransferState;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    LottieTransferState.prototype.transferState;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-lottie.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BaseDirective, LottieComponent, LottieDirective, LottieModule, LottieTransferState, transformAnimationFilenameToKey, IS_SAFARI as ɵb, LOTTIE_OPTIONS as ɵc, ANIMATION_CACHE as ɵd, isSafariFactory as ɵe, AnimationLoader as ɵf, AnimationCache as ɵg, LottieEventsFacade as ɵh };
//# sourceMappingURL=ngx-lottie.js.map
